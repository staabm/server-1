#
# Purpose:
#   This test ensures consistency in binlogging behavior for XA transactions
# that have all statements error and rollback, effectively leaving an "empty"
# transaction. In such cases, an empty XA transaction should be binlogged. The
# bug reported by MDEV-25616 revealed that an "empty" XA transaction would
# binlog an XA ROLLBACK or XA COMMIT event without a preceding setup, i.e.
# XA START through XA PREPARE. The bug presented differently for XA
# transactions consisting of transactional and non-transactional statements.
# Therefore, this test validates that an entire XA transaction is binlogged
# for different combinations of transactional or non-transactional statements.
# Note that the behavior changes when binlogging empty XA transactions
# depending on the binlog_row_format variables. That is, when the content of
# the transaction consists of errored transactional statements, in row format,
# an empty XA transaction will be binlogged; however, in mixed and statement
# formats, nothing will be written into the binary log.
#
# Methodology:
#   Create XA transactions with various combinations of erroring transactional
# or non-transactional statements. The binary log is examined to ensure all
# XA components are written. Chain replication is used, i.e.
# (primary->replica->replica), to ensure replica binlogging is consistent with
# manual execution. The transactional and non-transactional tables use InnoDB
# and MyISAM, respectively.
#
# Parameters
#   $expect_transactional_xa_binlog : Boolean indicating whether or not an
#       errored transactional statement should result in XA statements written
#       into the binary log.
#
# References:
#   MDEV-25616: Binlog event for XA COMMIT is generated without matching
#               XA START, replication aborts
#
--source include/have_log_bin.inc

--let $rpl_server_count= 3
--let $rpl_topology= 1->2->3
--source include/rpl_init.inc

--connection server_1
-- source include/have_innodb.inc
--connection server_2
-- source include/have_innodb.inc
--connection server_3
-- source include/have_innodb.inc
--connection server_1

--echo #
--echo # Test Case 1: An XA transaction without any statements should not be
--echo # binlogged
--let $trx_statements=

--let $xa_completion_action= COMMIT
--source include/rpl_xa_empty_transaction.inc

--let $xa_completion_action= ROLLBACK
--source include/rpl_xa_empty_transaction.inc


--echo #
--echo # Test Case 2: An XA transaction consisting of a successfully rolled back
--echo # statement should not be binlogged
--let $trx_statements= T

--let $xa_completion_action= COMMIT
--source include/rpl_xa_empty_transaction.inc

--let $xa_completion_action= ROLLBACK
--source include/rpl_xa_empty_transaction.inc


--echo #
--echo # Test Case 3: An XA transaction with a statement that cannot be rolled
--echo # back should be binlogged

# TODO: remove work-around MDEV-24654 when fixed.
--connection server_1
set @sav_binlog_format = @@binlog_format;
set @@binlog_format = row;
set @@global.binlog_format = row;
--let $trx_statements= N

--let $xa_completion_action= COMMIT
--source include/rpl_xa_empty_transaction.inc

--let $xa_completion_action= ROLLBACK
--source include/rpl_xa_empty_transaction.inc

--connection server_1
set @@binlog_format = @sav_binlog_format;
set @@global.binlog_format = @sav_binlog_format;


--echo #
--echo # Test Case 4: An XA transaction with multiple statements that can all
--echo # be rolled back should not be binlogged
--let $trx_statements= T,T

--let $xa_completion_action= COMMIT
--source include/rpl_xa_empty_transaction.inc

--let $xa_completion_action= ROLLBACK
--source include/rpl_xa_empty_transaction.inc


--echo #
--echo # Test Case 5: A mixed XA transaction consisting of one statement that
--echo # can successfully be rolled back (first statement), and another that
--echo # can not (second statement) should be binlogged

--connection server_1
set @sav_binlog_format = @@binlog_format;
set @@binlog_format = row;
set @@global.binlog_format = row;
--let $trx_statements= T,N

--let $xa_completion_action= COMMIT
--source include/rpl_xa_empty_transaction.inc

--let $xa_completion_action= ROLLBACK
--source include/rpl_xa_empty_transaction.inc

--connection server_1
set @@binlog_format = @sav_binlog_format;
set @@global.binlog_format = @sav_binlog_format;


--echo #
--echo # Test Case 6: A mixed XA transaction consisting of one statement that
--echo # cannot successfully be rolled back (first statement), and another that
--echo # can (second statement) should be binlogged

--connection server_1
set @sav_binlog_format = @@binlog_format;
set @@binlog_format = row;
set @@global.binlog_format = row;
--let $trx_statements= N,T

--let $xa_completion_action= COMMIT
--source include/rpl_xa_empty_transaction.inc

--let $xa_completion_action= ROLLBACK
--source include/rpl_xa_empty_transaction.inc

--connection server_1
set @@binlog_format = @sav_binlog_format;
set @@global.binlog_format = @sav_binlog_format;

--echo #
--echo # Test Case 7: An XA transaction consisting of two failed
--echo # non-transactional statements should be binlogged

--connection server_1
set @sav_binlog_format = @@binlog_format;
set @@binlog_format = row;
set @@global.binlog_format = row;
--let $trx_statements= N,N

--let $xa_completion_action= COMMIT
--source include/rpl_xa_empty_transaction.inc

--let $xa_completion_action= ROLLBACK
--source include/rpl_xa_empty_transaction.inc

--connection server_1
set @@binlog_format = @sav_binlog_format;
set @@global.binlog_format = @sav_binlog_format;


# MDEV-32257 dangling XA-rollback in binlog from emtpy XA
# create a case of XA ROLLBACK gets to binlog while its XAP was not and
# try replicate it.
# Expected result is both slaves error out.
--connection server_1
--let $binlog_start = query_get_value(SHOW MASTER STATUS, Position, 1)
--let $binlog_file =  query_get_value(SHOW MASTER STATUS, File, 1)
create table t_not_in_binlog (a int) engine=innodb;
flush logs;
--source include/save_master_gtid.inc
--let $binlog_file=query_get_value(SHOW MASTER STATUS, File, 1)

# External connection XID access after disconnect is subject to race.
# "(" open parenthesis to remember # of connection before ...
--source include/count_sessions.inc

--connect(con1,localhost,root,,)
call mtr.add_suppression("XAER_NOTA: Unknown XID");

SET sql_log_bin=0;
XA START 'a';
insert into t_not_in_binlog set a=1;
XA END 'a';
XA PREPARE 'a';
--disconnect con1

--connection server_1
# .. ")" close parenthesis, to wait until con1 fully releases access to xid.
--source include/wait_until_count_sessions.inc
xa recover;
#
# replicate orphan XAR to server 2,3 and expect the error first
# after that compensate it.

--error 0
XA ROLLBACK 'a';
# cleanup at once
drop table t_not_in_binlog;
--source include/save_master_gtid.inc

--connection server_2
--echo  XAER_NOTA: Unknown XID
--let $slave_sql_errno= 1397
--source include/wait_for_slave_sql_error.inc

# "("
--source include/count_sessions.inc

--connect (con2,127.0.0.1,root,,test,$SERVER_MYPORT_2,)
SET sql_log_bin=0;
XA START 'a';
insert into t_not_in_binlog set a=1;
XA END 'a';
XA PREPARE 'a';
--disconnect con2

--connection server_2
# ")"
--source include/wait_until_count_sessions.inc

xa recover;
--source include/start_slave.inc
--source include/sync_with_master_gtid.inc

--connection server_3
--echo  XAER_NOTA: Unknown XID
--let $slave_sql_errno= 1397
--source include/wait_for_slave_sql_error.inc

# "("
--source include/count_sessions.inc

--connect (con3,127.0.0.1,root,,test,$SERVER_MYPORT_3,)
SET sql_log_bin=0;
XA START 'a';
insert into t_not_in_binlog set a=1;
XA END 'a';
XA PREPARE 'a';
--disconnect con3

--connection server_3
# ")"
--source include/wait_until_count_sessions.inc

xa recover;
--source include/start_slave.inc
--source include/sync_with_master_gtid.inc

#
# Cleanup
--connection server_1
--source include/rpl_end.inc

--echo # End of rpl_xa_empty_transaction.test
